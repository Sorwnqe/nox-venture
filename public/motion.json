{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"video","usesPingPong":false,"src":"/motion.mp4","playbackRate":0.35,"loop":true,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uVideoTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor;const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);ivec2 texSize = textureSize(uVideoTexture, 0); float texWidth = float(texSize.x); float texHeight = float(texSize.y); float videoAspect = texWidth / texHeight;float screenAspect = (uResolution.x / uResolution.y); vec2 centeredUV = uv;if (0 == 1) { vec2 centered = uv - 0.5; if (screenAspect < videoAspect) { centeredUV = vec2( (uv.x - 0.5) * (screenAspect / videoAspect), uv.y - 0.5) + 0.5; } else { centeredUV = vec2( uv.x - 0.5, (uv.y - 0.5) * (videoAspect / screenAspect) ) + 0.5; } centeredUV += (bg.rg * 2.0 - 1.0) * 0.0000; } else { vec2 pos = vec2(0.4979202704180063, 0.4401037880385824) + mix(vec2(0), (uMousePos-0.5), 0.0000); centeredUV = centeredUV - pos; centeredUV.x *= screenAspect; centeredUV = (centeredUV) / 2.0000; centeredUV = centeredUV * rot(-0.0783 * 2.0 * PI); centeredUV.x /= videoAspect; centeredUV += 0.5; centeredUV += (bg.rg * 2.0 - 1.0) * 0.0000; if(centeredUV.x < 0.0 || centeredUV.x > 1.0 || centeredUV.y < 0.0 || centeredUV.y > 1.0) { fragColor = bg; return; } }vec4 color = texture(uVideoTexture, centeredUV);if(0 > 0) { color.rgb = blend(0, bg.rgb, color.rgb); }color.rgb = mix(bg.rgb, color.rgb, 0.8700) * color.a; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"ascii","usesPingPong":false,"mix":0.7,"trackMouse":0.45,"mouseMomentum":0.2,"animating":false,"isMask":0,"states":{"appear":[],"scroll":[],"hover":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"hover","id":"0175c38e-03ee-4bc5-b6af-643fe4640a41","prop":"mix","transition":{"duration":1000,"ease":"linear","delay":1950,"forwardsOnly":0},"progress":0,"rawProgress":0,"lastProgress":null,"value":1,"triggerOnElement":1,"breakpoints":["Desktop","Tablet","Mobile"],"uniformData":{"type":"1f","name":"uMix"}}]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uSprite; uniform sampler2D uCustomTexture; uniform float uMix;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float GLYPH_HEIGHT = 40.0; const float DEFAULT_NUM_SPRITES = 10.0; const float DEFAULT_NUM_ROWS = 6.0;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.42000000000000004) + mix(vec2(0), (uMousePos-0.5), 0.4500); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = (0.1200 + 0.01) * 0.05;float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection; vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec4 bg = texture(uTexture, vTextureCoord); vec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)); luminance = mix(luminance, 1.0 - luminance, float(0)); float gamma = mix(0.0, 4.0, 0.4700); luminance = pow(luminance, gamma);float scaleFactor = gridSize / GLYPH_HEIGHT;ivec2 customTextureSize = textureSize(uCustomTexture, 0); float customSpriteWidth = float(customTextureSize.x); float numSprites = mix(DEFAULT_NUM_SPRITES, customSpriteWidth / GLYPH_HEIGHT, float(0 == 6)); float numGlyphRows = mix(DEFAULT_NUM_ROWS, 1.0, float(0 == 6));float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0); float glyphIndex = mix(5.0 - float(0), 0.0, float(0 == 6));float normalizedSpriteSizeX = 1.0 / numSprites; float normalizedSpriteSizeY = 1.0 / numGlyphRows;vec2 spriteSheetUV = vec2( spriteIndex * normalizedSpriteSizeX, glyphIndex / numGlyphRows );vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection; vec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;spriteSheetUV += vec2( localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY );vec4 spriteColor = vec4(0.0);spriteColor = texture(uSprite, spriteSheetUV); float alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4; vec3 col = mix(cc, vec3(0, 0.9803921568627451, 0.9333333333333333), float(0)); vec3 dithered = mix( mix(vec3(0.0), vec3(1.0), float(0)), col, alpha ); color.rgb = mix(bg.rgb, dithered, uMix); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/ascii_spritesheet_larger.png","sampler":"uSprite"}},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"spotlight","usesPingPong":false,"trackMouse":0.91,"mouseMomentum":0.22,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.4100 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(1, 0)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (0.4100 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(0, 1)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 0.4100) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }vec4 getPointlight(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.9100); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec4 color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.2400 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.2400 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.5400 * 3.; vec3 base = color.rgb * vec3(1, 0.8941176470588236, 0.8862745098039215) * max(0., spot) * intensity; color.rgb = color.rgb * 1.0000 + base * diff * vec3(1, 0.8941176470588236, 0.8862745098039215) * max(0., spot) * intensity; color.rgb += specular * vec3(1, 0.8941176470588236, 0.8862745098039215) * max(0., spot * 4.) * 0.3900; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 getColor(vec2 uv) { return getPointlight(uv); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":true},{"prop":"pass","value":2,"includeBg":true}]},"id":"effect2"}],"options":{"name":"Trainloop AI - Motion Assets (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.29","id":"OMXTU1xXLg6n5Mvq26PE"}